import DirichletNeumann as dn
"""
Note that the "exact" u(gx) is generated by solving the problem with a finite element discretisation for
the entire coupled diff equation. Therfore the smallest devation will be between fem and fem, as that
u(gx) is an exact representation of what the method converges to. You will gate the same result between
FVM/FEM when f1=f2 = 0 as then the two methods are equivalent. 

We also force equidistant grids on FDM as adaptive FDM is not implemented
"""

#######################################  Problem Setup ##############################################

dirDisc = "FEM" # FDM,FEM,FVM
neuDisc = "FVM" # FDM,FEM,FVM
n1 = 10 # number of gridpoints for dirdisc
n2 = 10 # number of gridpoints for neudisc
# dirdisc on [x1,gx] neudisc on [gx,x2]
x1 = 0.0
gx = 1.1
x2 = 2.0
#u(x1), u(x2)
u1 = 4.0
u2 = 5.0
lmd1=1.0
lmd2=1.0
#f1,f2 for dirichlet/neuman part of the diff eq
f1 = lambda x: 0
f2 = lambda x: 0



print("Anticipated Convergence Rate")
print((lmd1/lmd2)*((gx-x1)/(x2-gx)))

##############################   Generate the numerical results ####################################

if(dirDisc=="FDM"):
    discdir = dn.fdm.FDM
    dirEqui = True 
elif(dirDisc=="FEM"):
    discdir = dn.fem.FEM
    dirEqui = False 
elif(dirDisc=="FVM"):
    discdir = dn.fvm.FVM
    dirEqui = False 
else:
    raise RuntimeError("Discretisations have to be FDM,FEM,FVM")

if(neuDisc=="FDM"):
    discneu = dn.fdm.FDM
    neuEqui = True 
elif(neuDisc=="FEM"):
    discneu = dn.fem.FEM
    neuEqui = False
elif(neuDisc=="FVM"):
    discneu = dn.fvm.FVM
    neuEqui = False
else:
    raise RuntimeError("Discretisations have to be FDM,FEM,FVM")


print("Devations for [equi, uniform, boundary dense, boundary sparse] grids are")
print(dn.getDiff(discdir,discneu,x1,gx,x2,u1,u2,lmd1,lmd2,n1,n2,dirEqui=dirEqui,neuEqui=neuEqui,f1=f1,f2=f2))
